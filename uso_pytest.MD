ğŸ§ª Guia Definitivo de Uso do Pytest em Python

Autor: Reinaldo

VersÃ£o: 2.0 (Atualizada para 2025)

Frameworks abordados: pytest, pytest-xdist, pytest-playwright, pytest-mock

## 1. ğŸ“˜ O que Ã© o Pytest?

O pytest Ã© um dos frameworks de teste mais populares e poderosos do ecossistema Python.

Ele oferece uma forma simples, declarativa e Pythonic de escrever testes â€” desde unitÃ¡rios atÃ© testes de integraÃ§Ã£o e fim a fim.

**Principais vantagens:**
*   **Sintaxe Simples:** vocÃª escreve `assert` como no Python puro.
*   **Descoberta AutomÃ¡tica:** pytest encontra os testes automaticamente.
*   **Fixtures:** permitem gerenciar dependÃªncias e estados de teste.
*   **Ecosistema de Plugins:** integraÃ§Ã£o com Django, FastAPI, Playwright, cobertura de cÃ³digo, mocks, paralelizaÃ§Ã£o e muito mais.
*   **Excelente RelatÃ³rio de Falhas:** mensagens ricas e fÃ¡ceis de ler.

## 2. âš™ï¸ InstalaÃ§Ã£o

Ã‰ sempre recomendado o uso de um ambiente virtual.

````bash
pip install pytest
````

Plugins Ãºteis:
````bash
pip install pytest-mock pytest-cov pytest-xdist pytest-playwright
````

## 3. ğŸ§® Escrevendo o primeiro teste
CÃ³digo a ser testado â€” calculadora.py
```python
def somar(a, b):
    """Soma dois nÃºmeros."""
    return a + b

def subtrair(a, b):
    """Subtrai dois nÃºmeros."""
    return a - b
```

Arquivo de teste â€” test_calculadora.py
```python
from calculadora import somar, subtrair

def test_somar():
    """Testa a funÃ§Ã£o somar com nÃºmeros positivos."""
    assert somar(2, 3) == 5
    assert somar(10, 10) == 20

def test_subtrair():
    """Testa a subtraÃ§Ã£o simples."""
    assert subtrair(10, 5) == 5
```

Executar:
````bash
pytest -v
````

## 4. âš¡ Fixtures â€“ InjeÃ§Ã£o de DependÃªncias ReutilizÃ¡veis

Fixtures sÃ£o funÃ§Ãµes que preparam um contexto (dados, conexÃµes, objetos) e o injetam nos testes automaticamente.

Fixture simples â€” test_dados.py
```python
import pytest

@pytest.fixture
def dados_iniciais():
    """Fixture que retorna um dicionÃ¡rio de exemplo."""
    print("\n(SETUP) Criando dicionÃ¡rio...")
    return {"nome": "Ana", "idade": 30}

def test_verificar_nome(dados_iniciais):
    assert dados_iniciais["nome"] == "Ana"

def test_verificar_idade(dados_iniciais):
    assert isinstance(dados_iniciais["idade"], int)
```


Execute com:

````bash
pytest -s
````

## 5. ğŸ”„ Fixtures com Setup e Teardown

Use yield dentro da fixture para executar cÃ³digo antes e depois dos testes (setup/teardown).

```python
@pytest.fixture
def cliente_db():
    print("\n(SETUP) Conectando ao banco de dados...")
    db = conectar_ao_db()
    yield db
    print("\n(TEARDOWN) Desconectando do banco de dados...")
    db.desconectar()
```

## 6. ğŸ·ï¸ Marcadores e Agrupamentos

Marcadores permitem categorizar e filtrar testes.

```python
import pytest
import time, sys

@pytest.mark.smoke
def test_funcionalidade_essencial():
    assert True

@pytest.mark.slow
def test_funcionalidade_lenta():
    time.sleep(2)
    assert True

@pytest.mark.skip(reason="Ainda nÃ£o implementado")
def test_funcionalidade_futura():
    assert False

@pytest.mark.skipif(sys.version_info < (3, 10), reason="Requer Python 3.10+")
def test_python10():
    assert True

@pytest.mark.xfail(reason="Bug conhecido #123")
def test_com_bug():
    assert 1 == 2
```

## 7. ğŸš€ Testes em Paralelo com pytest-xdist

Para projetos grandes, paralelize:

````bash
pytest -n 4
````

Ou use todos os nÃºcleos disponÃ­veis:

````bash
pytest -n auto
````

## 8. ğŸ”€ ParametrizaÃ§Ã£o de Testes
```python
import pytest
from calculadora import somar

@pytest.mark.parametrize("a,b,resultado", [
    (2, 3, 5),
    (-1, 1, 0),
    (10, 10, 20),
])
def test_somar_varios(a, b, resultado):
    assert somar(a, b) == resultado
```

## 9. âŒ Testando ExceÃ§Ãµes
```python
import pytest

def dividir(a, b):
    if b == 0:
        raise ValueError("DivisÃ£o por zero nÃ£o permitida")
    return a / b

def test_divisao_erro():
    with pytest.raises(ValueError, match="DivisÃ£o por zero"):
        dividir(1, 0)
```

## 10. ğŸ”§ ConfiguraÃ§Ã£o com pytest.ini
VS Code
(rerun without)
### O arquivo pytest.ini Ã© um arquivo de configuraÃ§Ã£o que permite definir opÃ§Ãµes padrÃ£o para o pytest, evitando a necessidade de digitÃ¡-las repetidamente na linha de comando.

[pytest]: Esta Ã© a seÃ§Ã£o principal que contÃ©m todas as configuraÃ§Ãµes do pytest.
markers: Registra marcadores personalizados. Isso evita erros de digitaÃ§Ã£o e permite que o pytest saiba quais marcadores sÃ£o intencionais. No exemplo, smoke, slow e api sÃ£o registrados com suas descriÃ§Ãµes.

testpaths: Especifica os diretÃ³rios onde o pytest deve procurar por testes. No exemplo, os testes serÃ£o procurados apenas na pasta tests.

python_files: Define os padrÃµes de nome de arquivo que o pytest considerarÃ¡ como arquivos de teste. No exemplo, arquivos que comeÃ§am com test_ ou terminam com _test serÃ£o coletados.

addopts: Adiciona opÃ§Ãµes de linha de comando que serÃ£o executadas por padrÃ£o em cada execuÃ§Ã£o do pytest. As opÃ§Ãµes do Playwright sÃ£o configuradas aqui:
--browser: Especifica em qual navegador (ou navegadores) os testes devem ser executados. VocÃª pode listar chromium, firefox e webkit.
--screenshot only-on-failure: Captura uma imagem da tela automaticamente, mas a salva apenas se o teste falhar.
--video retain-on-failure: Grava um vÃ­deo da execuÃ§Ã£o do teste e o mantÃ©m somente se o teste falhar.
--tracing on: Habilita o rastreamento do Playwright, que gera um arquivo de rastreio detalhado para depuraÃ§Ã£o pÃ³s-execuÃ§Ã£o.
--numprocesses 4: OpÃ§Ã£o do pytest-xdist que executa os testes em paralelo usando 4 processos, acelerando a execuÃ§Ã£o.

```ini
# filepath: pytest.ini
[pytest]
markers =
    smoke: Testes essenciais de validaÃ§Ã£o
    slow: Testes lentos
    api: Testes de API
addopts = 
    --browser chromium
    --browser firefox
    --browser webkit
    --screenshot only-on-failure
    --video retain-on-failure
    --tracing on
    --numprocesses 4
testpaths = tests
python_files = test_*.py *_test.py
```

## 11. ğŸ“ˆ RelatÃ³rio de Cobertura de CÃ³digo
````bash
pytest --cov=calculadora --cov-report=term-missing --cov-report=html
````


Gera um relatÃ³rio no console e um HTML em htmlcov/index.html.

## 12. ğŸ§© Integrando Pytest com Playwright

O plugin pytest-playwright permite automatizar navegadores (Chromium, Firefox, WebKit) facilmente.

InstalaÃ§Ã£o:
````bash
pip install pytest-playwright
playwright install
````

Exemplo de Fixture com Page:
```python
# filepath: tests/test_google.py
def test_titulo_google(page):
    """Verifica o tÃ­tulo da pÃ¡gina principal do Google."""
    page.goto("https://www.google.com")
    assert "Google" in page.title()
```

Fixture personalizada para login automatizado:
```python
import pytest

@pytest.fixture(scope="session")
def pagina_logada(browser):
    """Abre o navegador, faz login e retorna pÃ¡gina autenticada."""
    context = browser.new_context()
    page = context.new_page()
    page.goto("https://meusistema.com/login")
    page.fill("#usuario", "admin")
    page.fill("#senha", "123456")
    page.click("#entrar")
    page.wait_for_selector("#dashboard")
    yield page
    context.close()

def test_dashboard_acesso(pagina_logada):
    """Verifica se a pÃ¡gina do dashboard carrega corretamente."""
    assert "Dashboard" in pagina_logada.title()
```

## 13. ğŸŒ Mockando RequisiÃ§Ãµes com Pytest + Requests + pytest-mock

Usar o plugin pytest-mock simplifica o uso de mocks, sem precisar do unittest.mock manualmente.

Exemplo â€” Mockando uma requisiÃ§Ã£o com requests.get
```python
import pytest
import requests

def buscar_usuario():
    resposta = requests.get("https://api.example.com/users/1")
    return resposta.json()

def test_buscar_usuario_mockado(mocker):
    """Mocka a funÃ§Ã£o requests.get para simular uma API externa."""
    mock_response = mocker.Mock()
    mock_response.json.return_value = {"id": 1, "nome": "Reinaldo"}
    mocker.patch("requests.get", return_value=mock_response)

    resultado = buscar_usuario()
    assert resultado["nome"] == "Reinaldo"
```

Mockando RequisiÃ§Ã£o dentro do Playwright:
```python
def test_mock_request(page):
    """Simula a resposta de uma API dentro do navegador."""
    page.route("**/api/dados", lambda route: route.fulfill(
        status=200,
        content_type="application/json",
        body='{"usuario":"mockado","status":"ok"}'
    ))

    page.goto("https://meusistema.com/dashboard")
    response = page.evaluate("fetch('/api/dados').then(r => r.json())")
    assert response["usuario"] == "mockado"
```

## 14. â±ï¸ Dicas AvanÃ§adas de Uso DiÃ¡rio
*   `pytest -s` â†’ mostra `print()` no terminal
*   `pytest -x` â†’ para no primeiro erro
*   `pytest --lf` â†’ roda apenas os Ãºltimos testes que falharam
*   `pytest -v -m "smoke and not slow"` â†’ filtros de marcadores compostos

## 15. ğŸ’¡ Boas PrÃ¡ticas
*   Cada teste deve isolar comportamento independente.
*   Nomeie claramente os testes com verbos: `test_calcula_media`, `test_login_sucesso`, etc.
*   Use fixtures reutilizÃ¡veis em `conftest.py` (escopos: function, class, module, session).
*   Sempre use `pytest-cov` em pipelines CI/CD para medir cobertura.
*   Evite chamadas reais de rede; prefira mockar requisiÃ§Ãµes (consistÃªncia + performance).

## 16. ğŸŒ Estrutura de Projeto Recomendada
```plaintext
/automation_playwright_python
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ calculadora.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ conftest.py        # Fixtures globais
â”‚   â”œâ”€â”€ test_calculadora.py
â”‚   â”œâ”€â”€ test_api_mock.py
â”‚   â””â”€â”€ test_ui_login.py
â”œâ”€â”€ pytest.ini
â”œâ”€â”€ requirements.txt
â””â”€â”€ README.md
```

âœ… ConclusÃ£o

Com o pytest, pytest-mock, pytest-cov, pytest-xdist e pytest-playwright, vocÃª tem uma suÃ­te completa para:

*   Testes unitÃ¡rios e de integraÃ§Ã£o
*   Testes de interface automatizados
*   Mock de chamadas HTTP
*   ExecuÃ§Ã£o paralela e cobertura de cÃ³digo
*   ManutenÃ§Ã£o facilitada com fixtures organizadas

Reinaldo, quer que eu te monte tambÃ©m um exemplo prÃ¡tico de conftest.py completo com fixtures de Playwright e mocks integrados (como um setup real de automaÃ§Ã£o web + API)?
